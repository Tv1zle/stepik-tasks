#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <string>
#include <algorithm>

/*Есть две коробки, первая размером A1×B1×C1, вторая размером A2×B2×C2. Определите, можно ли разместить одну из этих коробок внутри другой, при условии, что поворачивать коробки можно только на 90 градусов вокруг ребер.

Формат входных данных
Программа получает на вход числа A1, B1, C1, A2, B2, C2.

Формат выходных данных
Программа должна вывести одну из следующих строчек:
Boxes are equal, если коробки одинаковые,
The first box is smaller than the second one, если первая коробка может быть положена во вторую,
The first box is larger than the second one, если вторая коробка может быть положена в первую,
Boxes are incomparable, во всех остальных случаях.

Sample Input 1:

1
2
3
3
2
1
Sample Output 1:

Boxes are equal

Sample Input 2 :

	2
	2
	3
	3
	2
	1
	Sample Output 2:

The first box is larger than the second one
*/


/*
int main() {
    int a1, b1, c1, a2, b2, c2;
    std::cin >> a1 >> b1 >> c1 >> a2 >> b2 >> c2;
    if (a1 > b1) {
        int temp;
        temp = a1;
        a1 = b1;
        b1 = temp;
    }
    if (a1 > c1) {
        int temp;
        temp = a1;
        a1 = c1;
        c1 = temp;
    }
    if (b1 > c1) {
        int temp;
        temp = b1;
        b1 = c1;
        c1 = temp;
    }
    if (a2 > b2) {
        int temp;
        temp = a2;
        a2 = b2;
        b2 = temp;
    }
    if (a2 > c2) {
        int temp;
        temp = a2;
        a2 = c2;
        c2 = temp;
    }
    if (b2 > c2) {
        int temp;
        temp = b2;
        b2 = c2;
        c2 = temp;
    }

    if ((a1 == a2) && (b1 == b2) && (c1 == c2))
    {
        std::cout << "Boxes are equal";
    }
    else if ((a1 <= a2) && (b1 <= b2) && (c1 <= c2))
    {
        std::cout << "The first box is smaller than the second one";
    }
    else if ((a1 >= a2) && (b1 >= b2) && (c1 >= c2))
    {
        std::cout << "The first box is larger than the second one";
    }
    else
    {
        std::cout << "Boxes are incomparable";
    }
    */





/*Определите наименьшее расстояние между двумя локальными максимумами последовательности натуральных чисел, завершающейся числом 0. Если в последовательности нет двух локальных максимумов, выведите число 0.

Начальное и конечное значение при этом локальными максимумами не считаются.

Расстоянием считается количество пробелов между элементами. В качестве примера смотрите первый тест.

Формат входных данных
Вводится последовательность целых чисел, оканчивающаяся числом 0 (само число 0 в последовательность не входит, а служит как признак ее окончания).
Формат выходных данных
Выведите ответ на задачу.
Sample Input 1:

1
2
1
1
2
1
2
1
0
Sample Output 1:

2
Sample Input 2:

1
2
3
0
Sample Output 2:

0
*/


/*
int main()
{
    int n, max = 0, count = 0, mincount = 0;
    std::cin >> n;

    while (n != 0)
    {
        std::cin >> n;
        if (n == 0)
        {
            break;
        }


        if (n == max)
        {
            count += 1;
            if (mincount > count)
            {
                mincount = count;
            }
            if (mincount == 0)
            {
                mincount = count;
            }
            count = 0;
        }


        if (max < n)
        {
            max = n;
            count = 0;
        }


        if (max > n)
        {
            count += 1;
        }
    }

    std::cout << mincount;  
}
*/





/*
N кеглей выставили в один ряд, занумеровав их слева направо числами от 1 до N. Затем по этому ряду бросили K шаров, при этом i-й шар сбил все кегли с номерами от li до ri включительно. Определите, какие кегли остались стоять на месте.

Формат входных данных

Программа получает на вход количество кеглей N и количество бросков K. Далее идет K пар чисел li, ri, при этом 1 ≤ li, ri ≤ N.

Формат выходных данных
Программа должна вывести последовательность из N символов, где j-й символ есть “I”, если j-я кегля осталась стоять, или “.”, если j-я кегля была сбита.
Sample Input:

10 3
8 10
2 5
3 6
Sample Output:

I.....I...
*/


/*
int main() {

    int N, K, I, r;
    std::cin >> N >> K;

    std::vector <int> kegli(N, 0);
    std::vector <int> strike;

    for (int i = 0; i < K; i++) {
        std::cin >> I >> r;
        for (int y = I - 1; y < r; y++) {
            kegli[y] = 1;
        }
    }

    for (int i = 0; i < N; i++) {
        if (kegli[i] == 0) {
            std::cout << "I";
        }
        else {
            std::cout << ".";
        }
    }
}
*/





/*
В кинотеатре n рядов по m мест в каждом (n и m не превосходят 20). В двумерном массиве хранится информация о проданных билетах, число 1 означает, что билет на данное место уже продан, число 0 означает, что место свободно. Поступил запрос на продажу k билетов на соседние места в одном ряду. Определите, можно ли выполнить такой запрос.

Формат входных данных
Программа получает на вход числа n и m. Далее идет n строк, содержащих m чисел (0 или 1), разделенных пробелами. Затем дано число k.
Формат выходных данных
Программа должна вывести номер ряда, в котором есть k подряд идущих свободных мест. Если таких рядов несколько, то выведите номер наименьшего подходящего ряда. Если подходящего ряда нет, выведите число 0.

Sample Input:

3 4
0 1 0 1
1 0 0 1
1 1 1 1
2
Sample Output:

2
*/


/*
int main() {
    int n, m;
    std::cin >> n >> m;

    int mass[20][20];

    for (int i = 0; i < n; i++) {
        for (int y = 0; y < m; y++) {
            std::cin >> mass[i][y];
        }
    }

    int k, a;
    std::cin >> k;
    int count = 0;
    int mincount = 0;


    for (int i = 0; i < n; i++) {
        for (int y = 0; y < m; y++) {
            if (mass[i][y] == 0) {
                count += 1;
            }
            else {
                count = 0;
            }

            if (count >= k) {
                std::cout << i + 1;
                return 0;
            }



        }
        count = 0;
    }

    std::cout << 0;


}
*/





/*
По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “змейкой”, как показано в примере.

Формат входных данных
Вводятся два числа n и m, каждое из которых не превышает 30.
Формат выходных данных
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:

3 5
Sample Output:

   1   2   3   4   5
  10   9   8   7   6
  11  12  13  14  15
  */


/*
int main() {
    int n, m, y = 0;
    std::cin >> n >> m;

    int mass[30][30];
    int count = 1;


    for (int i = 0; i < n; i++) {
        if (i % 2 == 0) {
            for (int y = 0; y < m; y++) {
                mass[i][y] = count;
                count += 1;

            }
        }
        else {
            for (int y = m - 1; y >= 0; y--) {
                mass[i][y] = count;
                count += 1;
            }
        }
    }


    for (int i = 0; i < n; i++) {
        for (int y = 0; y < m; y++) {
            printf("%4d", mass[i][y]);
        }
        std::cout << "\n";
    }
}
*/





/*
По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m “диагоналями”, как показано в примере.
Формат входных данных
Вводятся два числа n и m, не превышающие 100.

Формат выходных данных
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:

3 5
Sample Output:

   1   2   4   7  10
   3   5   8  11  13
   6   9  12  14  15
   */


/*
int main() {
    int n, m;
    std::cin >> n >> m;
    int mass[100][100];
    int count = 1;

    for(int j = 0; j < m + n - 1; j++) {
        for (int i = 0; i < n; i++) {
            for (int y = 0; y < m; y++) {
                if (i + y == j) {
                    mass[i][y] = count;
                    count+=1;
                }
            }
        }
    }

    for(int i = 0; i < n; i++) {
        for (int y = 0; y < m; y++) {
            printf("%4d", mass[i][y]);
        }
        std::cout << "\n";
    }


  return 0;
}
*/





/*
Даны числа n и m. Заполните массив размером n × m в шахматном порядке: клетки одного цвета заполнены нулями, а другого цвета - заполнены числами натурального ряда сверху вниз, слева направо. В левом верхнем углу записано число 1.
Формат входных данных
Вводятся два числа n и m, не превышающие 100.

Формат выходных данных
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:

3 5
Sample Output:

   1   0   2   0   3
   0   4   0   5   0
   6   0   7   0   8
*/


/*
int main() {
    int n, m;
    std::cin >> n >> m;
    int count = 1;
    int mass[100][100];

    for(int i = 0; i < n; i++) {
        for(int y = 0; y < m; y++) {
            if (i % 2 != 0 && y % 2 == 0) {
                mass[i][y] = 0;
            }
            else if (i % 2 == 0 && y % 2 != 0) {
                mass[i][y] = 0;
            }
            else {
                mass[i][y] = count;
                count+=1;
            }
        }
    }

    for(int i = 0; i < n; i++) {
        for (int y = 0; y < m; y++) {
            printf("%4d", mass[i][y]);
        }
        std::cout << "\n";
    }
}
*/





/*
По данным числам n и m заполните двумерный массив размером n×m числами от 1 до n×m по спирали, выходящей из левого верхнего угла и закрученной по часовой стрелке, как показано в примере.
Формат входных данных
Вводятся два числа n и m, не превышающие 100.

Формат выходных данных
Выведите полученный массив, отводя на вывод каждого элемента ровно 4 символа.

Sample Input:

4 5
Sample Output:

   1   2   3   4   5
  14  15  16  17   6
  13  20  19  18   7
  12  11  10   9   8
*/


/*
int main() {
    int n, m;
    std::cin >> n >> m;
    int num = 1;
    int i = 0, j = 0, l = 0, u = 1, r = m, d = n;
    int mass[100][100];

    while (num <= m * n) {
        while (j < r) {
            if (num > n * m) {
                break;
            }
            mass[i][j] = num;
            num += 1;
            j += 1;
        }
        j--;
        i++;
        r--;

        while (i < d) {
            if (num > n * m) {
                break;
            }
            mass[i][j] = num;
            num += 1;
            i += 1;
        }
        i--;
        j--;
        d--;

        while (j > l) {
            if (num > n * m) {
                break;
            }
            mass[i][j] = num;
            num += 1;
            j -= 1;
        }
        l++;

        while (i > u) {
            if (num > n * m) {
                break;
            }
            mass[i][j] = num;
            num += 1;
            i -= 1;
        }
        u++;
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            printf("%4d", mass[i][j]);
        }
        std::cout << "\n";
    }
}
*/





/*
В небоскребе n этажей. Известно, что если уронить стеклянный шарик с этажа номер p, и шарик разобьется, то если уронить шарик с этажа номер p+1, то он тоже разобьется. Также известно, что при броске с последнего этажа шарик всегда разбивается.Вы хотите определить минимальный номер этажа, при падении с которого шарик разбивается. Для проведения экспериментов у вас есть два шарика. Вы можете разбить их все, но в результате вы должны абсолютно точно определить этот номер.
Определите, какого числа бросков достаточно, чтобы заведомо решить эту задачу.
Формат входных данных
Программа получает на вход количество этажей в небоскребе.
Формат выходных данных
Требуется вывести наименьшее число бросков, при котором можно всегда решить задачу.
Примечание
Комментарий к первому примеру. Нужно бросить шарик со 2-го этажа. Если он разобьется, то бросим второй шарик с 1-го этажа, а если не разобьется - то бросим шарик с 3-го этажа.
Подсказки
1. Как следует действовать, если шарик был бы только один?
2. Пусть шариков два и мы бросили один шарик с этажа номер k. Как мы будем действовать в зависимости от того, разобьется ли шарик или нет?
3. Пусть f(n) - это минимальное число бросков, за которое можно определить искомый этаж, если бы в небоскребе было n этажей. Выразите f(n) через значения f(a) для меньших значений a.
Sample Input 1:

4
Sample Output 1:

2
Sample Input 2:

5
Sample Output 2:

3
*/


/*
int ball(int k, int n = 1) {
    if ((n + n*n) / 2 >= k - 1) {
        return n;
    }
    return ball(k, n + 1);
}


int main()
{
  int k;
  std::cin >> k;
  std::cout << ball(k);
}
*/






/*
По данной строке определите, является ли она палиндромом (то есть, читается одинаково как слева-направо, так и справа-налево).

Входные данные

На вход подается 1 строка без пробелов.

Выходные данные

Необходимо вывести yes, если строка является палиндромом, и no в противном случае.

Sample Input:

kayak
Sample Output:

yes
*/


/*
int main() {
    std::string s;
    std::cin >> s;

    if (s == std::string(s.rbegin(), s.rend()))
    {
        std::cout << "yes";
    }
    else
    {
        std::cout << "no";
    }

}
*/





/*
Найдите в данной строке самое длинное слово и выведите его.

Входные данные

Вводится одна строка. Слова в ней отделены одним пробелом.

Выходные данные

Выведите самое длинное слово. Если таких слов несколько, то выводить нужно, которое встречается раньше.

Sample Input:

Everyone of us has all we need
Sample Output:

Everyone
*/


/*
int main() {
    std::string s, s1, smax;
    getline(std::cin, s);
    int count = 0, max = 0;

    for (int i = 0; i < s.size(); i++) {
        if (s[i] != ' ') {
            count += 1;
            s1 += s[i];
        }
        else
        {
            if (max < count)
            {
                smax = s1;
                s1 = "";
                max = count;
                count = 0;
            }
            else
            {
                count = 0;
                s1 = "";
            }

        }


    }
    if (s1.size() > smax.size()) {
        std::cout << s1;
    }
    else
    {
        std::cout << smax;
    }

}*/





/*
Вам дан словарь, состоящий из пар слов. Каждое слово является синонимом к парному ему слову. Все слова в словаре различны. Для одного данного слова определите его синоним.

Входные данные

Программа получает на вход количество пар синонимов N. Далее следует N строк, каждая строка содержит ровно два слова-синонима. После этого следует одно слово.

Выходные данные

Программа должна вывести синоним к данному слову.

Sample Input:

3
Hello Hi
Bye Goodbye
List Array
Goodbye
Sample Output:

Bye
*/


/*
int main() {
    int N;
    std::cin >> N;
    std::map <std::string, std::string> arr, rev;
    std::string x, y;

    for (int i = 0; i < N; i++)
    {
        std::cin >> x >> y;
        arr[x] = y;
        rev[y] = x;
    }

    std::cin >> x;
    auto it = arr.find(x);
    if (it != arr.end())
    {
        std::cout << it->second;
    }
    else
    {
        y = x;
        auto it = rev.find(y);
        if (it != rev.end())
        {
            std::cout << it->second;
        }
    }
}
*/





/*
В обувном магазине продается обувь разного размера. Известно, что одну пару обуви можно надеть на другую, если она хотя бы на три размера больше. В магазин пришел покупатель. Требуется определить, какое наибольшее количество пар обуви сможет предложить ему продавец так, чтобы он смог надеть их все одновременно.

Входные данные

Сначала вводится размер ноги покупателя (обувь меньшего размера он надеть не сможет), затем количество пар обуви в магазине и размер каждой пары. Размер — натуральное число, не превосходящее 100, количество пар обуви в магазине не превосходит 1000.

Выходные данные

Выведите единственное число — максимальное количество пар обуви.

Sample Input:

26
5
30 35 40 41 42
Sample Output:

3
*/


/*
int main() {
    int n, count = 0, onesize, prev;
    std::cin >> onesize;
    std::cin >> n;
    std::vector <int> a(n);

    for (int i = 0; i < n; i++)
    {
        std::cin >> a[i];
    }

    sort(a.begin(), a.end());

    for (int i = 0; i < n; i++)
    {
        if (a[i] >= onesize)
        {
            prev = a[i];
            count += 1;
            for (int j = 0; j < n; j++)
            {
                if (a[j] - prev >= 3)
                {
                    count += 1;
                    prev = a[j];
                }
            }
            break;
        }
    }

    std::cout << count;
}
*/





/*
Во время проведения олимпиады каждый из участников получил свой идентификационный номер – натуральное число. Необходимо отсортировать список участников олимпиады по количеству набранных ими баллов.

Входные данные

На первой строке дано число N (1 ≤ N ≤ 1000) – количество участников. На каждой следующей строке даны идентификационный номер и набранное число баллов соответствующего участника. Все числа во входном файле не превышают 105.

Выходные данные

В выходной файл выведите исходный список в порядке убывания баллов. Если у некоторых участников одинаковые баллы, то их между собой нужно упорядочить в порядке возрастания идентификационного номера.

Sample Input 1:

3
101 80
305 90
200 14
Sample Output 1:

305 90
101 80
200 14
Sample Input 2:

3
20 80
30 90
25 90
Sample Output 2:

25 90
30 90
20 80
*/


/*
struct olymp {
    int id;
    int res;
};

bool comp(olymp a, olymp b) {
    if (a.res == b.res) {
        return (a.id < b.id);
    }
    else if (a.res != b.res)
    {
        return (a.res > b.res);
    }
}

int main() {
    int n, idd, ress;
    std::cin >> n;
    std::vector <olymp> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> idd >> ress;
        a[i] = {idd, ress}; // создание пары значение - номер
    }


    sort(a.begin(), a.end(), comp);


    for (auto now : a) {
        std::cout << now.id << " " << now.res << "\n";

    }

}
*/





/*
Выведите фамилии и имена учащихся в порядке убывания их среднего балла.

Входные данные

Заданы сначала количество учащихся n, затем n строк, каждая из которых содержит фамилию, имя и три числа (оценки по трем предметам: математике, физике, информатике). Данные в строке разделены одним пробелом. Оценки принимают значение от 1 до 5.

Выходные данные

Необходимо вывести пары фамилия-имя по одной на строке, разделяя фамилию и имя одним пробелом. Выводить оценки не нужно. Если несколько учащихся имеют одинаковые средние баллы, то их нужно выводить в порядке, заданном во входных данных.

Sample Input:

3
Markov Valeriy 5 5 5
Sergey Petrov 1 1 1
Petrov Petr 3 3 3
Sample Output:

Markov Valeriy
Petrov Petr
Sergey Petrov
*/


/*
struct olymp {
    std::string student;
    int medium;
};


bool comp(olymp a, olymp b) {
    return a.medium > b.medium;
}


int main() {
    int n, grateone, gratetwo, gratethree;
    std::string name, surname;
    std::cin >> n;
    std::vector <olymp> a(n);
    for (int i = 0; i < n; i++) {
        std::cin >> name >> surname >> grateone >> gratetwo >> gratethree;
        int medium = grateone + gratetwo + gratethree;

        std::string student = name;
        student += " ";
        student += surname;

        a[i] = { student, medium }; // создание пары значение - номер
    }


    stable_sort(a.begin(), a.end(), comp);


    for (auto now : a) {
        std::cout << now.student << "\n";
    }
}
*/